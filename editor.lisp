(in-package :repl)

(macrolet ((def (name)
                `(cffi:defcfun (,name) :int
                               (count :int)
                               (key :int))))
  (def "rl_abort")
  (def "rl_newline")
  (def "rl_arrow_keys")
  (def "rl_backward_byte")
  (def "rl_backward_char")
  (def "rl_rubout")
  (def "rl_backward_kill_line")
  (def "rl_backward_kill_word")
  (def "rl_backward_word")
  (def "rl_beginning_of_history")
  (def "rl_beg_of_line")
  (def "rl_call_last_kbd_macro")
  (def "rl_capitalize_word")
  (def "rl_char_search")
  (def "rl_backward_char_search")
  (def "rl_clear_screen")
  (def "rl_complete")
  (def "rl_copy_backward_word")
  (def "rl_copy_forward_word")
  (def "rl_copy_region_to_kill")
  (def "rl_delete")
  (def "rl_delete_or_show_completions")
  (def "rl_delete_horizontal_space")
  (def "rl_digit_argument")
  (def "rl_do_lowercase_version")
  (def "rl_downcase_word")
  (def "rl_dump_functions")
  (def "rl_dump_macros")
  (def "rl_dump_variables")
  (def "rl_emacs_editing_mode")
  (def "rl_end_kbd_macro")
  (def "rl_end_of_history")
  (def "rl_end_of_line")
  (def "rl_exchange_point_and_mark")
  (def "rl_rubout_or_delete")
  (def "rl_forward_byte")
  (def "rl_forward_char")
  (def "rl_forward_search_history")
  (def "rl_forward_word")
  (def "rl_history_search_backward")
  (def "rl_history_search_forward")
  (def "rl_history_substr_search_backward")
  (def "rl_history_substr_search_forward")
  (def "rl_insert_comment")
  (def "rl_insert_completions")
  (def "rl_kill_full_line")
  (def "rl_kill_line")
  (def "rl_kill_region")
  (def "rl_kill_word")
  (def "rl_menu_complete")
  (def "rl_backward_menu_complete")
  (def "rl_get_next_history")
  (def "rl_noninc_forward_search")
  (def "rl_noninc_reverse_search")
  (def "rl_noninc_forward_search_again")
  (def "rl_noninc_reverse_search_again")
  (def "rl_old_menu_complete")
  (def "rl_overwrite_mode")
  (def "rl_kill_text"))

(defvar *editor-column* 0)

(defun accept-line ()
  (setq *editor-column* 0)
  (rl-newline 1 0))

(defun finish-sexp-p (string)
  (handler-case (progn
                  (read-from-string string)
                  t)
    (error () (return-from finish-sexp-p nil))))

(defun repl-newline (arg key)
  (declare (ignore arg key))
  (rl:insert-text (string #\newline)))

(defun repl-return (arg key)
  (declare (ignore arg key))
  (if (finish-sexp-p rl:*line-buffer*)
      (accept-line)
      (rl:insert-text (string #\newline))))

(rl:bind-keyseq (string #\newline) #'repl-newline)
(rl:bind-keyseq (string #\return) #'repl-return)

(defun readline (prompt)
  (rl:readline :prompt prompt))

(defun current-linum ()
  (1+ (count #\newline rl:*line-buffer* :end rl:*point*)))

(defun nlines ()
  (1+ (count #\newline rl:*line-buffer*)))

(defun current-column ()
  (- rl:*point* (bol-point rl:*line-buffer* rl:*point*)))

(defun bol-point (&optional (line-buffer rl:*line-buffer*)
                            (point rl:*point*))
  (or (loop :for i :downfrom point :to 1 :do
        (when (char= #\newline (aref line-buffer (1- i)))
          (return i)))
      0))

(defun eol-point (&optional (line-buffer rl:*line-buffer*)
                            (point rl:*point*))
  (or (position #\newline line-buffer :start point)
      (length line-buffer)))

(defun prev-line (arg key)
  (declare (ignore arg key))
  (when (< 1 (current-linum))
    (let* ((bol-point (bol-point rl:*line-buffer* rl:*point*))
           (column (current-column))
           (pl-bol-point (bol-point rl:*line-buffer* (1- bol-point)))
           (pl-width (- bol-point pl-bol-point 1)))
      (setq *editor-column* (max *editor-column* column))
      (setq rl:*point* (+ pl-bol-point (min pl-width *editor-column*))))))

(rl:bind-keyseq "\\C-p" #'prev-line)

(defun next-line (arg key)
  (declare (ignore arg key))
  (when (< (current-linum) (nlines))
    (let* ((bol-point (bol-point rl:*line-buffer* rl:*point*))
           (column (current-column))
           (nl-bol-point (1+ (eol-point rl:*line-buffer* rl:*point*)))
           (nl-width (- (eol-point rl:*line-buffer* nl-bol-point)
                        nl-bol-point)))
      (setq *editor-column* (max *editor-column* column))
      (setq rl:*point* (+ nl-bol-point (min nl-width *editor-column*))))))

(rl:bind-keyseq "\\C-n" #'next-line)

(defun forward-char (arg key)
  (declare (ignore arg key))
  (when (< rl:*point* (length rl:*line-buffer*))
    (incf rl:*point*)
    (setq *editor-column* (current-column))))

(rl:bind-keyseq "\\C-f" #'forward-char)

(defun backward-char (arg key)
  (declare (ignore arg key))
  (when (< 0 rl:*point*)
    (decf rl:*point*)
    (setq *editor-column* (current-column))))

(rl:bind-keyseq "\\C-b" #'backward-char)

(defun beginning-of-line (arg key)
  (declare (ignore arg key))
  (setq rl:*point* (bol-point))
  (setq *editor-column* (current-column)))

(rl:bind-keyseq "\\C-a" #'beginning-of-line)

(defun end-of-line (arg key)
  (declare (ignore arg key))
  (setq rl:*point* (eol-point))
  (setq *editor-column* (current-column)))

(rl:bind-keyseq "\\C-e" #'end-of-line)

(defun beginning-of-buffer (arg key)
  (declare (ignore arg key))
  (rl-beg-of-line 1 0))

(rl:bind-keyseq "\\e<" #'beginning-of-buffer)

(defun end-of-buffer (arg key)
  (declare (ignore arg key))
  (rl-end-of-line 1 0))

(rl:bind-keyseq "\\e>" #'end-of-buffer)

(defun previous-history (arg key)
  (declare (ignore arg key))
  (rl-get-previous-history 1 0))

(rl:bind-keyseq "\\ep" #'previous-history)

(defun next-history (arg key)
  (declare (ignore arg key))
  (rl-get-next-history 1 0))

(rl:bind-keyseq "\\en" #'next-history)

(defun kill-line (arg key)
  (let ((orig-point rl:*point*))
    (end-of-line 1 0)
    (if (/= orig-point rl:*point*)
        (rl-kill-text orig-point rl:*point*)
        (rl-kill-text orig-point (1+ orig-point)))
    (setq rl:*point* orig-point)
    (setq rl:*mark* rl:*point*)))

(rl:bind-keyseq "\\C-k" #'kill-line)
